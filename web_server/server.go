package webserver

// * -----------------------------------------------------------
// *
// * Auto-Generated by gson-api-generator on 2015-12-09 00:28:46.338910925 -0400 EDT
// *
// * Command Line Args
// * ./gson-api-generator -action=new -goPath=github.com/mccraymt/ms-crypto -dbType=orchestrate
// *
// * -----------------------------------------------------------

import (
	"log"
	"net/http"
	"net/http/httputil"
	"strings"

	"github.com/go-martini/martini"
	"github.com/martini-contrib/cors"
	"github.com/martini-contrib/gorelic"
	"github.com/martini-contrib/gzip"
	"github.com/martini-contrib/render"
	"github.com/mccraymt/ms-crypto/app/routes"
	"github.com/mccraymt/ms-crypto/app/utils"
	cfg "github.com/mccraymt/ms-crypto/config"
	gapi "github.com/obieq/gson-api"
	"github.com/twinj/uuid"
)

// API_SERVER_INFO => used to construct relationship urls in responses
//                    should pull values from config settings
var API_SERVER_INFO = gapi.JSONApiServerInfo{BaseURL: "http://crypto-ms.mccraymt.com", Prefix: "v1"}

// NewServer => Constructor
func NewServer() *martini.ClassicMartini {
	// switch the uuid format
	uuid.SwitchFormat(uuid.CleanHyphen)

	// configure martini
	m := martini.Classic()

	// Martini Logger
	m.Use(utils.MartiniLogger())

	// map to the logger type used by handlers
	// m.Map(log.Logger)
	// m.Map(logrus.New())

	// gzip every request
	// TODO: Angular only runs on modern browsers and all modern browsers support gzip
	//       However, if we ever support a native app or the like, then will need to
	//       verify that the new client supports gzip
	m.Use(gzip.All(gzip.Options{
		CompressionLevel: gzip.BestSpeed,
	}))

	// NOTE: interesting bug.  by default, Martini Class loads the recovery handler
	//       however, when the gzip handler is loaded, it conflicts w/ the recovery handler
	//       appears that loading the recovery handler again rectifies the issue, which
	//       is a 200 is returned instead of a 500 for Panics
	// NOTE: furthermore, use our modified Recovery handler b/c it's been modified with better logrus/loggly integration
	m.Use(utils.Recovery())

	// configure NewRelic
	if strings.TrimSpace(cfg.Config.NewRelicKey) != "" {
		gorelic.InitNewrelicAgent(cfg.Config.NewRelicKey, "ms-crypto-"+cfg.Config.Environment, true)
		m.Use(gorelic.Handler)
	}

	// Martini Renderer
	m.Use(render.Renderer())

	if cfg.Config.Debug {
		// Intercept all HTTP Requests and dump to console
		// NOTE: don't use logrus/logrusly logging b/c it will eat up loggly data storage
		m.Use(func(req *http.Request) {
			log.Println("-- BEGIN HTTP REQUEST INTERCEPTOR (DON'T RUN IN PRODUCTION!!) ---")
			dump, _ := httputil.DumpRequest(req, true)
			log.Println(string(dump))
			log.Println("--- END HTTP REQUEST INTERCEPTOR (DON'T RUN IN PRODUCTION!!) ---")
		})
	}

	// CORS configuration
	m.Use(cors.Allow(&cors.Options{
		AllowAllOrigins: true,
		//AllowOrigins:     []string{"https://*.foo.com"},
		// NOTE: no need to allow PUT b/c PATCH suffices
		AllowMethods:     []string{"PATCH", "GET", "POST", "DELETE", "OPTIONS", "HEAD"},
		AllowHeaders:     []string{"Origin", "X-Requested-With", "Content-Type", "Accept", "X-AUTH-TOKEN", "X-API-VERSION"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Default Route, which returns the App's Version and Deployment Environment
	m.Get("/", func() (int, string) {
		return 200, cfg.Config.Version + "\n" + cfg.Config.Environment
	})

	// Domain Name validation for LetsEncrypt
	s := strings.Split(cfg.Config.SSLCertSimpleHttpText, ".")
	short := s[0]
	m.Get("/.well-known/acme-challenge/"+short, func() (int, string) {
		return 200, cfg.Config.SSLCertSimpleHttpText
	})

	// LoadIE9ProxyRoutes => returns html response to satisfy IE9 security
	//                       requirements when calling APIs via javascript
	m.Get("/proxy.html", func() string {
		return `<!doctype html><script src="https://d1pvkh5g3u3d4w.cloudfront.net/xdomain.js" data-master="*"></script>`
	})

	m.Get("/hello", func() string {
		return "hello world" // HTTP 200 : "hello world"
	})

	// Controller Routes
	m.Group("/v1", func(r martini.Router) {
		routes.LoadSampleRoutes(r, API_SERVER_INFO)
	})

	return m
}
