package webserver

// * -----------------------------------------------------------
// *
// * Auto-Generated by gson-api-generator on 2015-12-09 00:44:48.35899651 -0400 EDT
// *
// *
// * -----------------------------------------------------------

import (
	"net/http"
	"net/http/httptest"
	"time"

	"github.com/mccraymt/ms-crypto/app/resources"
	"github.com/go-martini/martini"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe("QuoteIntent", func() {
	var (
		// dbQuoteIntent        *models.QuoteIntentDocument = goar.ToAR(&models.QuoteIntentDocument{}).(*models.QuoteIntentDocument)
		gQuoteIntentResource *resources.QuoteIntent
		server               *martini.ClassicMartini
		request              *http.Request
		gRecorder            *httptest.ResponseRecorder
		gKVS                 = map[string]interface{}{}
	)

	BeforeEach(func() {
		var recorder *httptest.ResponseRecorder

		// instantiate a new web server
		server = NewServer()

		// Record HTTP responses
		gRecorder = httptest.NewRecorder()

		// Save a new QuoteIntent before each test
		gQuoteIntentResource = &resources.QuoteIntent{}
		recorder, gKVS = makeRESTRequest(HTTP_POST, "/v1/quote-intents", gQuoteIntentResource)
		Ω(recorder.Code).Should(Equal(201))
	})

	Context("GET", func() {
		Context("One", func() {
			BeforeEach(func() {
				// Set up a new GET request before every test
				request, _ = http.NewRequest("GET", "/v1/quote-intents/"+gKVS["id"].(string), nil)
			})

			Context("when no QuoteIntents exist", func() {
				It("should return a 401 status code and an errors collection", func() {
					// dbQuoteIntent.Truncate()            // delete all Orchestrate records created during previous test
					time.Sleep(5000 * time.Millisecond) // NOTE: there's a timing issue with deleting an Orchestrate collection

					server.ServeHTTP(gRecorder, request)
					Ω(gRecorder.Code).Should(Equal(404))
					Ω(gRecorder.Body).Should(MatchJSON(expectedNotFoundResponse()))
				})
			})

			Context("when a QuoteIntent exists", func() {
				It("should return a 200 status code and a single json api resource", func() {
					server.ServeHTTP(gRecorder, request)
					Ω(gRecorder.Code).Should(Equal(200))

					createdAt := parseCreatedAt(gRecorder)

					// verify response
					orderedKeys := map[int]string{0: "quote-intent", 1: "created-at"}
					gKVS["created-at"] = createdAt
					Ω(gRecorder.Body).Should(MatchJSON(expectedGetOneResponse("quote-intents", orderedKeys, gKVS)))
				})
			})
		})

		Context("All", func() {
			BeforeEach(func() {
				// Set up a new GET request before every test
				request, _ = http.NewRequest("GET", "/v1/quote-intents", nil)
			})

			Context("when no QuoteIntents exist", func() {
				It("should return a 200 status code and an empty array", func() {
					// dbQuoteIntent.Truncate()            // delete all Orchestrate records created during previous test
					time.Sleep(5000 * time.Millisecond) // NOTE: there's a timing issue with deleting an Orchestrate collection

					server.ServeHTTP(gRecorder, request)
					Ω(gRecorder.Code).Should(Equal(200))
					Ω(gRecorder.Body).Should(MatchJSON(expectedEmptyGetResponse()))
				})
			})

			Context("when a QuoteIntent exists", func() {
				It("should return a 200 status code and an array", func() {
					server.ServeHTTP(gRecorder, request)
					Ω(gRecorder.Code).Should(Equal(200))

					createdAt := parseCreatedAt(gRecorder)

					// verify response
					orderedKeys := map[int]string{0: "quote-intent", 1: "created-at"}
					gKVS["created-at"] = createdAt
					Ω(gRecorder.Body).Should(MatchJSON(expectedGetAllResponse("quote-intents", orderedKeys, gKVS)))
				})
			})
		})
	})

	Context("POST", func() {
		It("should return a 201 Status Code", func() {
			r, kvs := makeRESTRequest(HTTP_POST, "/v1/quote-intents", &resources.QuoteIntent{})
			Ω(r.Code).Should(Equal(201))

			// verify response
			orderedKeys := map[int]string{0: "quote-intent", 1: "created-at"}
			Ω(r.Body).Should(MatchJSON(expectedPostPatchResponse("quote-intents", orderedKeys, kvs)))
		})
	})

	Context("PATCH", func() {
		It("should return a 200 status code", func() {
			resource := &resources.QuoteIntent{}
			r, kvs := makeRESTRequest(HTTP_PATCH, "/v1/quote-intents/"+gKVS["id"].(string), resource)

			// verify response
			orderedKeys := map[int]string{0: "quote-intent", 1: "created-at", 2: "updated-at"}
			Ω(r.Body).Should(MatchJSON(expectedPostPatchResponse("quote-intents", orderedKeys, kvs)))
		})
	})
})
